package com.insecurity.service;

import com.insecurity.exception.ResourceNotFoundException;
import com.insecurity.model.Vulnerability;
import com.insecurity.repository.AssetRepository;
import com.insecurity.repository.VulnerabilityRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Service
public class VulnerabilityService {
    @Autowired
    private VulnerabilityRepository vulnerabilityRepository;

    @Autowired
    private AssetRepository assetRepository;

    public List<Vulnerability> getAllVulnerabilities() {
        return vulnerabilityRepository.findAll();
    }

    public Optional<Vulnerability> getVulnerabilityById(Long id) {
        return vulnerabilityRepository.findById(id);
    }

    @Transactional
    public Vulnerability createVulnerability(Vulnerability vulnerability) {
        validateSeverity(vulnerability.getSeverity());
        vulnerability.setDiscoveredDate(LocalDate.now());
        return vulnerabilityRepository.save(vulnerability);
    }

    @Transactional
    public Vulnerability updateVulnerability(Long id, Vulnerability vulnerabilityDetails) {
        Vulnerability vulnerability = vulnerabilityRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Vulnerability not found with id " + id));
        validateSeverity(vulnerabilityDetails.getSeverity());
        vulnerability.setName(vulnerabilityDetails.getName());
        vulnerability.setSeverity(vulnerabilityDetails.getSeverity());
        vulnerability.setStatus(vulnerabilityDetails.getStatus());
        vulnerability.setDescription(vulnerabilityDetails.getDescription());
        vulnerability.setDiscoveredBy(vulnerabilityDetails.getDiscoveredBy());
        vulnerability.setResolution(vulnerabilityDetails.getResolution());
        vulnerability.setDiscoveredDate(vulnerabilityDetails.getDiscoveredDate());
        vulnerability.setAsset(vulnerabilityDetails.getAsset());
        return vulnerabilityRepository.save(vulnerability);
    }

    public void deleteVulnerability(Long id) {
        if (!vulnerabilityRepository.existsById(id)) {
            throw new ResourceNotFoundException("Vulnerability not found with id " + id);
        }
        vulnerabilityRepository.deleteById(id);
    }

    public List<Vulnerability> getVulnerabilitiesBySeverity(String severity) {
        return vulnerabilityRepository.findBySeverity(severity);
    }

    public List<Vulnerability> getVulnerabilitiesByStatus(String status) {
        return vulnerabilityRepository.findByStatus(status);
    }

    public List<Vulnerability> getVulnerabilitiesByAsset(Long assetId) {
        return vulnerabilityRepository.findByAsset_Id(assetId);
    }

    private void validateSeverity(String severity) {
        if (!(severity.equals("Low") || severity.equals("Medium") || severity.equals("High") || severity.equals("Critical"))) {
            throw new IllegalArgumentException("Invalid severity level: " + severity);
        }
    }
}
